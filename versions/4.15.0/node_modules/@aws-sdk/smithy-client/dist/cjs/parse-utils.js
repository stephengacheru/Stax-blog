"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
/**
 * Give an input string, strictly parses a boolean value.
 *
 * @param value The boolean string to parse.
 * @returns true for "true", false for "false", otherwise an error is thrown.
 */
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
exports.parseBoolean = parseBoolean;
/*
 * Asserts a value is a boolean and returns it.
 *
 * @param value A value that is expected to be a boolean.
 * @returns The value if it's a boolean, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}`);
};
exports.expectBoolean = expectBoolean;
/**
 * Asserts a value is a number and returns it.
 *
 * @param value A value that is expected to be a number.
 * @returns The value if it's a number, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}`);
};
exports.expectNumber = expectNumber;
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
/**
 * Asserts a value is a 32-bit float and returns it.
 *
 * @param value A value that is expected to be a 32-bit float.
 * @returns The value if it's a float, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectFloat32 = (value) => {
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        // IEEE-754 is an imperfect representation for floats. Consider the simple
        // value `0.1`. The representation in a 32-bit float would look like:
        //
        // 0 01111011 10011001100110011001101
        // Actual value: 0.100000001490116119384765625
        //
        // Note the repeating pattern of `1001` in the fraction part. The 64-bit
        // representation is similar:
        //
        // 0 01111111011 1001100110011001100110011001100110011001100110011010
        // Actual value: 0.100000000000000005551115123126
        //
        // So even for what we consider simple numbers, the representation differs
        // between the two formats. And it's non-obvious how one might look at the
        // 64-bit value (which is how JS represents numbers) and determine if it
        // can be represented reasonably in the 32-bit form. Primarily because you
        // can't know whether the intent was to represent `0.1` or the actual
        // value in memory. But even if you have both the decimal value and the
        // double value, that still doesn't communicate the intended precision.
        //
        // So rather than attempting to divine the intent of the caller, we instead
        // do some simple bounds checking to make sure the value is passingly
        // representable in a 32-bit float. It's not perfect, but it's good enough.
        // Perfect, even if possible to achieve, would likely be too costly to
        // be worth it.
        //
        // The maximum value of a 32-bit float. Since the 64-bit representation
        // could be more or less, we just round it up to the nearest whole number.
        // This further reduces our ability to be certain of the value, but it's
        // an acceptable tradeoff.
        //
        // Compare against the absolute value to simplify things.
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
exports.expectFloat32 = expectFloat32;
/**
 * Asserts a value is an integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}`);
};
exports.expectLong = expectLong;
/**
 * @deprecated Use expectLong
 */
exports.expectInt = exports.expectLong;
/**
 * Asserts a value is a 32-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectInt32 = (value) => expectSizedInt(value, 32);
exports.expectInt32 = expectInt32;
/**
 * Asserts a value is a 16-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectShort = (value) => expectSizedInt(value, 16);
exports.expectShort = expectShort;
/**
 * Asserts a value is an 8-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectByte = (value) => expectSizedInt(value, 8);
exports.expectByte = expectByte;
const expectSizedInt = (value, size) => {
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
/**
 * Asserts a value is not null or undefined and returns it, or throws an error.
 *
 * @param value A value that is expected to be defined
 * @param location The location where we're expecting to find a defined object (optional)
 * @returns The value if it's not undefined, otherwise throws an error
 */
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
exports.expectNonNull = expectNonNull;
/**
 * Asserts a value is an JSON-like object and returns it. This is expected to be used
 * with values parsed from JSON (arrays, objects, numbers, strings, booleans).
 *
 * @param value A value that is expected to be an object
 * @returns The value if it's an object, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    throw new TypeError(`Expected object, got ${typeof value}`);
};
exports.expectObject = expectObject;
/**
 * Asserts a value is a string and returns it.
 *
 * @param value A value that is expected to be a string.
 * @returns The value if it's a string, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    throw new TypeError(`Expected string, got ${typeof value}`);
};
exports.expectString = expectString;
/**
 * Asserts a value is a JSON-like object with only one non-null/non-undefined key and
 * returns it.
 *
 * @param value A value that is expected to be an object with exactly one non-null,
 *              non-undefined key.
 * @return the value if it's a union, undefined if it's null/undefined, otherwise
 *  an error is thrown.
 */
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = (0, exports.expectObject)(value);
    const setKeys = Object.entries(asObject)
        .filter(([_, v]) => v !== null && v !== undefined)
        .map(([k, _]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
exports.expectUnion = expectUnion;
/**
 * Parses a value into a double. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value A number or string representation of a double.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
};
exports.strictParseDouble = strictParseDouble;
/**
 * @deprecated Use strictParseDouble
 */
exports.strictParseFloat = exports.strictParseDouble;
/**
 * Parses a value into a float. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value A number or string representation of a float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
};
exports.strictParseFloat32 = strictParseFloat32;
// This regex matches JSON-style numbers. In short:
// * The integral may start with a negative sign, but not a positive one
// * No leading 0 on the integral unless it's immediately followed by a '.'
// * Exponent indicated by a case-insensitive 'E' optionally followed by a
//   positive/negative sign and some number of digits.
// It also matches both positive and negative infinity as well and explicit NaN.
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
/**
 * Asserts a value is a number and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
};
exports.limitedParseDouble = limitedParseDouble;
/**
 * @deprecated Use limitedParseDouble
 */
exports.handleFloat = exports.limitedParseDouble;
/**
 * @deprecated Use limitedParseDouble
 */
exports.limitedParseFloat = exports.limitedParseDouble;
/**
 * Asserts a value is a 32-bit float and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
};
exports.limitedParseFloat32 = limitedParseFloat32;
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
/**
 * Parses a value into an integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of an integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseLong = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
};
exports.strictParseLong = strictParseLong;
/**
 * @deprecated Use strictParseLong
 */
exports.strictParseInt = exports.strictParseLong;
/**
 * Parses a value into a 32-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of a 32-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
};
exports.strictParseInt32 = strictParseInt32;
/**
 * Parses a value into a 16-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of a 16-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseShort = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
};
exports.strictParseShort = strictParseShort;
/**
 * Parses a value into an 8-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of an 8-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseByte = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
};
exports.strictParseByte = strictParseByte;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7O0dBS0c7QUFDSSxNQUFNLFlBQVksR0FBRyxDQUFDLEtBQWEsRUFBVyxFQUFFO0lBQ3JELFFBQVEsS0FBSyxFQUFFO1FBQ2IsS0FBSyxNQUFNO1lBQ1QsT0FBTyxJQUFJLENBQUM7UUFDZCxLQUFLLE9BQU87WUFDVixPQUFPLEtBQUssQ0FBQztRQUNmO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsS0FBSyxHQUFHLENBQUMsQ0FBQztLQUMvRDtBQUNILENBQUMsQ0FBQztBQVRXLFFBQUEsWUFBWSxnQkFTdkI7QUFFRjs7Ozs7O0dBTUc7QUFDSSxNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQVUsRUFBdUIsRUFBRTtJQUMvRCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUN6QyxPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELElBQUksT0FBTyxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQzlCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxNQUFNLElBQUksU0FBUyxDQUFDLHlCQUF5QixPQUFPLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDL0QsQ0FBQyxDQUFDO0FBUlcsUUFBQSxhQUFhLGlCQVF4QjtBQUVGOzs7Ozs7R0FNRztBQUNJLE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBVSxFQUFzQixFQUFFO0lBQzdELElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ3pDLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELE1BQU0sSUFBSSxTQUFTLENBQUMsd0JBQXdCLE9BQU8sS0FBSyxFQUFFLENBQUMs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TyxJQUFBLG1CQUFXLEVBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDeEM7SUFDRCxPQUFPLElBQUEsbUJBQVcsRUFBQyxLQUFLLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUM7QUFQVyxRQUFBLGdCQUFnQixvQkFPM0I7QUFFRjs7Ozs7Ozs7O0dBU0c7QUFDSSxNQUFNLGVBQWUsR0FBRyxDQUFDLEtBQXNCLEVBQXNCLEVBQUU7SUFDNUUsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0Isb0VBQW9FO1FBQ3BFLHlFQUF5RTtRQUN6RSxPQUFPLElBQUEsa0JBQVUsRUFBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUN2QztJQUNELE9BQU8sSUFBQSxrQkFBVSxFQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzNCLENBQUMsQ0FBQztBQVBXLFFBQUEsZUFBZSxtQkFPMUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdpdmUgYW4gaW5wdXQgc3RyaW5nLCBzdHJpY3RseSBwYXJzZXMgYSBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYm9vbGVhbiBzdHJpbmcgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB0cnVlIGZvciBcInRydWVcIiwgZmFsc2UgZm9yIFwiZmFsc2VcIiwgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlQm9vbGVhbiA9ICh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGJvb2xlYW4gdmFsdWUgXCIke3ZhbHVlfVwiYCk7XG4gIH1cbn07XG5cbi8qXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBib29sZWFuIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBib29sZWFuLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYSBib29sZWFuLCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdEJvb2xlYW4gPSAodmFsdWU6IGFueSk6IGJvb2xlYW4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBudW1iZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGEgbnVtYmVyLCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdE51bWJlciA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG59O1xuXG5jb25zdCBNQVhfRkxPQVQgPSBNYXRoLmNlaWwoMiAqKiAxMjcgKiAoMiAtIDIgKiogLTIzKSk7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMzItYml0IGZsb2F0IGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSAzMi1iaXQgZmxvYXQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaWYgaXQncyBhIGZsb2F0LCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdEZsb2F0MzIgPSAodmFsdWU6IGFueSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkID0gZXhwZWN0TnVtYmVyKHZhbHVlKTtcbiAgaWYgKGV4cGVjdGVkICE9PSB1bmRlZmluZWQgJiYgIU51bWJlci5pc05hTihleHBlY3RlZCkgJiYgZXhwZWN0ZWQgIT09IEluZmluaXR5ICYmIGV4cGVjdGVkICE9PSAtSW5maW5pdHkpIHtcbiAgICAvLyBJRUVFLTc1NCBpcyBhbiBpbXBlcmZlY3QgcmVwcmVzZW50YXRpb24gZm9yIGZsb2F0cy4gQ29uc2lkZXIgdGhlIHNpbXBsZVxuICAgIC8vIHZhbHVlIGAwLjFgLiBUaGUgcmVwcmVzZW50YXRpb24gaW4gYSAzMi1iaXQgZmxvYXQgd291bGQgbG9vayBsaWtlOlxuICAgIC8vXG4gICAgLy8gMCAwMTExMTAxMSAxMDAxMTAwMTEwMDExMDAxMTAwMTEwMVxuICAgIC8vIEFjdHVhbCB2YWx1ZTogMC4xMDAwMDAwMDE0OTAxMTYxMTkzODQ3NjU2MjVcbiAgICAvL1xuICAgIC8vIE5vdGUgdGhlIHJlcGVhdGluZyBwYXR0ZXJuIG9mIGAxMDAxYCBpbiB0aGUgZnJhY3Rpb24gcGFydC4gVGhlIDY0LWJpdFxuICAgIC8vIHJlcHJlc2VudGF0aW9uIGlzIHNpbWlsYXI6XG4gICAgLy9cbiAgICAvLyAwIDAxMTExMTExMDExIDEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMTBcbiAgICAvLyBBY3R1YWwgdmFsdWU6IDAuMTAwMDAwMDAwMDAwMDAwMDA1NTUxMTE1MTIzMTI2XG4gICAgLy9cbiAgICAvLyBTbyBldmVuIGZvciB3aGF0IHdlIGNvbnNpZGVyIHNpbXBsZSBudW1iZXJzLCB0aGUgcmVwcmVzZW50YXRpb24gZGlmZmVyc1xuICAgIC8vIGJldHdlZW4gdGhlIHR3byBmb3JtYXRzLiBBbmQgaXQncyBub24tb2J2aW91cyBob3cgb25lIG1pZ2h0IGxvb2sgYXQgdGhlXG4gICAgLy8gNjQtYml0IHZhbHVlICh3aGljaCBpcyBob3cgSlMgcmVwcmVzZW50cyBudW1iZXJzKSBhbmQgZGV0ZXJtaW5lIGlmIGl0XG4gICAgLy8gY2FuIGJlIHJlcHJlc2VudGVkIHJlYXNvbmFibHkgaW4gdGhlIDMyLWJpdCBmb3JtLiBQcmltYXJpbHkgYmVjYXVzZSB5b3VcbiAgICAvLyBjYW4ndCBrbm93IHdoZXRoZXIgdGhlIGludGVudCB3YXMgdG8gcmVwcmVzZW50IGAwLjFgIG9yIHRoZSBhY3R1YWxcbiAgICAvLyB2YWx1ZSBpbiBtZW1vcnkuIEJ1dCBldmVuIGlmIHlvdSBoYXZlIGJvdGggdGhlIGRlY2ltYWwgdmFsdWUgYW5kIHRoZVxuICAgIC8vIGRvdWJsZSB2YWx1ZSwgdGhhdCBzdGlsbCBkb2Vzbid0IGNvbW11bmljYXRlIHRoZSBpbnRlbmRlZCBwcmVjaXNpb24uXG4gICAgLy9cbiAgICAvLyBTbyByYXRoZXIgdGhhbiBhdHRlbXB0aW5nIHRvIGRpdmluZSB0aGUgaW50ZW50IG9mIHRoZSBjYWxsZXIsIHdlIGluc3RlYWRcbiAgICAvLyBkbyBzb21lIHNpbXBsZSBib3VuZHMgY2hlY2tpbmcgdG8gbWFrZSBzdXJlIHRoZSB2YWx1ZSBpcyBwYXNzaW5nbHlcbiAgICAvLyByZXByZXNlbnRhYmxlIGluIGEgMzItYml0IGZsb2F0LiBJdCdzIG5vdCBwZXJmZWN0LCBidXQgaXQncyBnb29kIGVub3VnaC5cbiAgICAvLyBQZXJmZWN0LCBldmVuIGlmIHBvc3NpYmxlIHRvIGFjaGlldmUsIHdvdWxkIGxpa2VseSBiZSB0b28gY29zdGx5IHRvXG4gICAgLy8gYmUgd29ydGggaXQuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSB2YWx1ZSBvZiBhIDMyLWJpdCBmbG9hdC4gU2luY2UgdGhlIDY0LWJpdCByZXByZXNlbnRhdGlvblxuICAgIC8vIGNvdWxkIGJlIG1vcmUgb3IgbGVzcywgd2UganVzdCByb3VuZCBpdCB1cCB0byB0aGUgbmVhcmVzdCB3aG9sZSBudW1iZXIuXG4gICAgLy8gVGhpcyBmdXJ0aGVyIHJlZHVjZXMgb3VyIGFiaWxpdHkgdG8gYmUgY2VydGFpbiBvZiB0aGUgdmFsdWUsIGJ1dCBpdCdzXG4gICAgLy8gYW4gYWNjZXB0YWJsZSB0cmFkZW9mZi5cbiAgICAvL1xuICAgIC8vIENvbXBhcmUgYWdhaW5zdCB0aGUgYWJzb2x1dGUgdmFsdWUgdG8gc2ltcGxpZnkgdGhpbmdzLlxuICAgIGlmIChNYXRoLmFicyhleHBlY3RlZCkgPiBNQVhfRkxPQVQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIDMyLWJpdCBmbG9hdCwgZ290ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBlY3RlZDtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGFuIGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RMb25nID0gKHZhbHVlOiBhbnkpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGludGVnZXIsIGdvdCAke3R5cGVvZiB2YWx1ZX1gKTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGV4cGVjdExvbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdEludCA9IGV4cGVjdExvbmc7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMzItYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RJbnQzMiA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IGV4cGVjdFNpemVkSW50KHZhbHVlLCAzMik7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMTYtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RTaG9ydCA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IGV4cGVjdFNpemVkSW50KHZhbHVlLCAxNik7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGFuIDgtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RCeXRlID0gKHZhbHVlOiBhbnkpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4gZXhwZWN0U2l6ZWRJbnQodmFsdWUsIDgpO1xuXG50eXBlIEludFNpemUgPSAzMiB8IDE2IHwgODtcblxuY29uc3QgZXhwZWN0U2l6ZWRJbnQgPSAodmFsdWU6IGFueSwgc2l6ZTogSW50U2l6ZSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkID0gZXhwZWN0TG9uZyh2YWx1ZSk7XG4gIGlmIChleHBlY3RlZCAhPT0gdW5kZWZpbmVkICYmIGNhc3RJbnQoZXhwZWN0ZWQsIHNpemUpICE9PSBleHBlY3RlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICR7c2l6ZX0tYml0IGludGVnZXIsIGdvdCAke3ZhbHVlfWApO1xuICB9XG4gIHJldHVybiBleHBlY3RlZDtcbn07XG5cbmNvbnN0IGNhc3RJbnQgPSAodmFsdWU6IG51bWJlciwgc2l6ZTogSW50U2l6ZSkgPT4ge1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXkub2YodmFsdWUpWzBdO1xuICAgIGNhc2UgMTY6XG4gICAgICByZXR1cm4gSW50MTZBcnJheS5vZih2YWx1ZSlbMF07XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIEludDhBcnJheS5vZih2YWx1ZSlbMF07XG4gIH1cbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZCBhbmQgcmV0dXJucyBpdCwgb3IgdGhyb3dzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZGVmaW5lZFxuICogQHBhcmFtIGxvY2F0aW9uIFRoZSBsb2NhdGlvbiB3aGVyZSB3ZSdyZSBleHBlY3RpbmcgdG8gZmluZCBhIGRlZmluZWQgb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIG5vdCB1bmRlZmluZWQsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdE5vbk51bGwgPSA8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkLCBsb2NhdGlvbj86IHN0cmluZyk6IFQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBub24tbnVsbCB2YWx1ZSBmb3IgJHtsb2NhdGlvbn1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLW51bGwgdmFsdWVcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYW4gSlNPTi1saWtlIG9iamVjdCBhbmQgcmV0dXJucyBpdC4gVGhpcyBpcyBleHBlY3RlZCB0byBiZSB1c2VkXG4gKiB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBKU09OIChhcnJheXMsIG9iamVjdHMsIG51bWJlcnMsIHN0cmluZ3MsIGJvb2xlYW5zKS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdFxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gb2JqZWN0LCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdE9iamVjdCA9ICh2YWx1ZTogYW55KTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBvYmplY3QsIGdvdCAke3R5cGVvZiB2YWx1ZX1gKTtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgc3RyaW5nIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaWYgaXQncyBhIHN0cmluZywgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RTdHJpbmcgPSAodmFsdWU6IGFueSk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBKU09OLWxpa2Ugb2JqZWN0IHdpdGggb25seSBvbmUgbm9uLW51bGwvbm9uLXVuZGVmaW5lZCBrZXkgYW5kXG4gKiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGggZXhhY3RseSBvbmUgbm9uLW51bGwsXG4gKiAgICAgICAgICAgICAgbm9uLXVuZGVmaW5lZCBrZXkuXG4gKiBAcmV0dXJuIHRoZSB2YWx1ZSBpZiBpdCdzIGEgdW5pb24sIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLCBvdGhlcndpc2VcbiAqICBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RVbmlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgYXNPYmplY3QgPSBleHBlY3RPYmplY3QodmFsdWUpITtcblxuICBjb25zdCBzZXRLZXlzID0gT2JqZWN0LmVudHJpZXMoYXNPYmplY3QpXG4gICAgLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZClcbiAgICAubWFwKChbaywgX10pID0+IGspO1xuXG4gIGlmIChzZXRLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuaW9ucyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgbm9uLW51bGwgbWVtYmVyYCk7XG4gIH1cblxuICBpZiAoc2V0S2V5cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5pb25zIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBub24tbnVsbCBtZW1iZXIuIEtleXMgJHtzZXRLZXlzfSB3ZXJlIG5vdCBudWxsLmApO1xuICB9XG5cbiAgcmV0dXJuIGFzT2JqZWN0O1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGEgZG91YmxlLiBJZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIHVuZGVmaW5lZFxuICogd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHBhcnNlZCBieSB0aGUgc3RhbmRhcmRcbiAqIHBhcnNlRmxvYXQgd2l0aCBvbmUgZXhjZXB0aW9uOiBOYU4gbWF5IG9ubHkgYmUgZXhwbGljaXRseSBzZXQgYXMgdGhlIHN0cmluZ1xuICogXCJOYU5cIiwgYW55IGltcGxpY2l0IE5hbiB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgdGhyb3duLiBJZiBhbnlcbiAqIG90aGVyIHR5cGUgaXMgcHJvdmlkZWQsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZG91YmxlLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlRG91YmxlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXhwZWN0TnVtYmVyKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdE51bWJlcih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBzdHJpY3RQYXJzZURvdWJsZVxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VGbG9hdCA9IHN0cmljdFBhcnNlRG91YmxlO1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSBmbG9hdC4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgdGhlIHN0YW5kYXJkXG4gKiBwYXJzZUZsb2F0IHdpdGggb25lIGV4Y2VwdGlvbjogTmFOIG1heSBvbmx5IGJlIGV4cGxpY2l0bHkgc2V0IGFzIHRoZSBzdHJpbmdcbiAqIFwiTmFOXCIsIGFueSBpbXBsaWNpdCBOYW4gdmFsdWVzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIHRocm93bi4gSWYgYW55XG4gKiBvdGhlciB0eXBlIGlzIHByb3ZpZGVkLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZsb2F0LlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlRmxvYXQzMiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGV4cGVjdEZsb2F0MzIocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0RmxvYXQzMih2YWx1ZSk7XG59O1xuXG4vLyBUaGlzIHJlZ2V4IG1hdGNoZXMgSlNPTi1zdHlsZSBudW1iZXJzLiBJbiBzaG9ydDpcbi8vICogVGhlIGludGVncmFsIG1heSBzdGFydCB3aXRoIGEgbmVnYXRpdmUgc2lnbiwgYnV0IG5vdCBhIHBvc2l0aXZlIG9uZVxuLy8gKiBObyBsZWFkaW5nIDAgb24gdGhlIGludGVncmFsIHVubGVzcyBpdCdzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgJy4nXG4vLyAqIEV4cG9uZW50IGluZGljYXRlZCBieSBhIGNhc2UtaW5zZW5zaXRpdmUgJ0UnIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgYVxuLy8gICBwb3NpdGl2ZS9uZWdhdGl2ZSBzaWduIGFuZCBzb21lIG51bWJlciBvZiBkaWdpdHMuXG4vLyBJdCBhbHNvIG1hdGNoZXMgYm90aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgaW5maW5pdHkgYXMgd2VsbCBhbmQgZXhwbGljaXQgTmFOLlxuY29uc3QgTlVNQkVSX1JFR0VYID0gLygtPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyl8KC0/SW5maW5pdHkpfChOYU4pL2c7XG5cbmNvbnN0IHBhcnNlTnVtYmVyID0gKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goTlVNQkVSX1JFR0VYKTtcbiAgaWYgKG1hdGNoZXMgPT09IG51bGwgfHwgbWF0Y2hlc1swXS5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHJlYWwgbnVtYmVyLCBnb3QgaW1wbGljaXQgTmFOYCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBudW1iZXIgYW5kIHJldHVybnMgaXQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICogcmVwcmVzZW50YXRpb24gb2YgYSBub24tbnVtZXJpYyBudW1iZXIgdHlwZSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KSxcbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIHBhcnNlZC4gQW55IG90aGVyIHN0cmluZyB2YWx1ZSB3aWxsIHJlc3VsdCBpbiBhbiBleGNlcHRpb25cbiAqIGJlaW5nIHRocm93bi4gTnVsbCBvciB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZCBhcyB1bmRlZmluZWQuIEFueSBvdGhlclxuICogdHlwZSB3aWxsIHJlc3VsdCBpbiBhbiBleGNlcHRpb24gYmVpbmcgdGhyb3duLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIG51bWJlciBvciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBub24tbnVtZXJpYyBmbG9hdC5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhcyBhIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBsaW1pdGVkUGFyc2VEb3VibGUgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0U3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0TnVtYmVyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGxpbWl0ZWRQYXJzZURvdWJsZVxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlRmxvYXQgPSBsaW1pdGVkUGFyc2VEb3VibGU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGxpbWl0ZWRQYXJzZURvdWJsZVxuICovXG5leHBvcnQgY29uc3QgbGltaXRlZFBhcnNlRmxvYXQgPSBsaW1pdGVkUGFyc2VEb3VibGU7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMzItYml0IGZsb2F0IGFuZCByZXR1cm5zIGl0LiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9uLW51bWVyaWMgbnVtYmVyIHR5cGUgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSksXG4gKiB0aGUgdmFsdWUgd2lsbCBiZSBwYXJzZWQuIEFueSBvdGhlciBzdHJpbmcgdmFsdWUgd2lsbCByZXN1bHQgaW4gYW4gZXhjZXB0aW9uXG4gKiBiZWluZyB0aHJvd24uIE51bGwgb3IgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQgYXMgdW5kZWZpbmVkLiBBbnkgb3RoZXJcbiAqIHR5cGUgd2lsbCByZXN1bHQgaW4gYW4gZXhjZXB0aW9uIGJlaW5nIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9uLW51bWVyaWMgZmxvYXQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3QgbGltaXRlZFBhcnNlRmxvYXQzMiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXRTdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiBleHBlY3RGbG9hdDMyKHZhbHVlKTtcbn07XG5cbmNvbnN0IHBhcnNlRmxvYXRTdHJpbmcgPSAodmFsdWU6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwiTmFOXCI6XG4gICAgICByZXR1cm4gTmFOO1xuICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIGNhc2UgXCItSW5maW5pdHlcIjpcbiAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGZsb2F0IHZhbHVlOiAke3ZhbHVlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYW4gaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VMb25nID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gcGFyc2VJbnQgY2FuJ3QgYmUgdXNlZCBoZXJlLCBiZWNhdXNlIGl0IHdpbGwgc2lsZW50bHkgZGlzY2FyZCBhbnlcbiAgICAvLyBleGlzdGluZyBkZWNpbWFscy4gV2Ugd2FudCB0byBpbnN0ZWFkIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgcmV0dXJuIGV4cGVjdExvbmcocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0TG9uZyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBzdHJpY3RQYXJzZUxvbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlSW50ID0gc3RyaWN0UGFyc2VMb25nO1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSAzMi1iaXQgaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgMzItYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VJbnQzMiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHBhcnNlSW50IGNhbid0IGJlIHVzZWQgaGVyZSwgYmVjYXVzZSBpdCB3aWxsIHNpbGVudGx5IGRpc2NhcmQgYW55XG4gICAgLy8gZXhpc3RpbmcgZGVjaW1hbHMuIFdlIHdhbnQgdG8gaW5zdGVhZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55LlxuICAgIHJldHVybiBleHBlY3RJbnQzMihwYXJzZU51bWJlcih2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBleHBlY3RJbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSAxNi1iaXQgaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgMTYtYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VTaG9ydCA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHBhcnNlSW50IGNhbid0IGJlIHVzZWQgaGVyZSwgYmVjYXVzZSBpdCB3aWxsIHNpbGVudGx5IGRpc2NhcmQgYW55XG4gICAgLy8gZXhpc3RpbmcgZGVjaW1hbHMuIFdlIHdhbnQgdG8gaW5zdGVhZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55LlxuICAgIHJldHVybiBleHBlY3RTaG9ydChwYXJzZU51bWJlcih2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBleHBlY3RTaG9ydCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYW4gOC1iaXQgaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIDgtYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VCeXRlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gcGFyc2VJbnQgY2FuJ3QgYmUgdXNlZCBoZXJlLCBiZWNhdXNlIGl0IHdpbGwgc2lsZW50bHkgZGlzY2FyZCBhbnlcbiAgICAvLyBleGlzdGluZyBkZWNpbWFscy4gV2Ugd2FudCB0byBpbnN0ZWFkIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgcmV0dXJuIGV4cGVjdEJ5dGUocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0Qnl0ZSh2YWx1ZSk7XG59O1xuIl19